1	字符串大小写
	s="hello javen"
	s.title() -------> "Hello Javen"
	s.upper() -------> "HELLO JAVEN"
	s.lower() -------> "hello javen"
	
2	分拆与合并拼接字符串
	title='Alice in Wonderland'
	list=title.split() ---------->方法 split() 以空格为分隔符将字符串分拆成多个部分,并将这些部分都存储到一个列表中.

	s1="hello"
	s2="javen"
	s=s1+" "+s2 -----> "hello javen"
	"\n\t" ----------> \n表示转行，\t表示制表符

	可以使用方法 count() 来确定特定的单词或短语在字符串中出现了多少次

3	删除空白
	s=" hello "
	s.strip() -------> "hello" 删除头尾的空格
	s.lstrip() ------> "hello " 删除开头的空格
	s.rstrip() ------> " hello" 删除末尾的空格

4	乘方运算的表示
	10**6=1000000 表示10的6次方

5	将整数转换成字符串
	age=23
	print "he is " + str(age) + " years old!" 使用str()函数

6	判断变量类型
	使用type()函数，但存在一定的缺陷，即无法区分子类与父类。
	高端的用法是使用isinstance()函数。

6	列表
	列表是一个能让你存储成组的信息的东西，其中可以包含从几个到数百万个元素。
	在python中用[]来表示列表，并用,来分隔其中的元素
	命名列表时最好使用复数，以表明它是有许多元素组成的
	names=['jack','javen','rose','mike',23,34] 列表中可以放不同类型的变量
	names[3] -----> 'mike' 访问元素
	正向访问索引从0开始，反向访问索引从-1开始
	names[0]=10		修改元素
	names.append('curry')	列表末尾添加
	names.insert(1,'tom')	在索引位置1处插入元素，原来的元素在之前的位置的基础上向后顺延
	del names[0]	删除索引0处的元素
	names.pop()		弹出列表最后一个元素，可以将其用作他用，del是直接删除，无法用其他变量接住删掉的变量
	names.pop(2)	弹出索引为2的元素，用作他用
	names.remove('rose')	删除指定元素，不用知道位置，删除第一个遇到的该值，如果要全部删除就使用循环
	names.sort()	对列表中的元素进行永久排序，一般数字变量在前，字符串变量在后，数字按照从大到小，字符串按照首字母顺序，想反序排序的话，加入参数，这样写names.sort(reverse=true)
	names.sorted()	对列表中的元素进行临时排序，即可以将结果传到其他变量作他用，但是列表中元素是不改变顺序的
	names.reverse()	对列表中的元素进行永久性的调转顺序，即整个列表完全颠倒过来，想恢复的话，在执行一次颠倒就好了
	len(names)	获取列表的长度
	for name in names:		使用for循环就可以直接便利列表中的每个元素进行处理
	range(1,10)		创建一个1到9的数字列表

7	列表解析
	生成列表一般需要三四行代码，而列表解析只需要一行代码就能生成这样的列表。列表解析是将for循环和创建新元素的代码合并成一行，并自动附加新元素。
	squares=[value**2 for value in range(1,11)] --------> [1,4,9,16,25,36,49,64,81,100]

8	元组
	列表非常适合用于存储在程序运行期间可能变化的数据集。列表是可以修改的。然而，有时候你需要创建一系列不可修改的元素，元组可以满足这种需求。python将不能修改的值称为不可变的，而由不能修改的值组成的列表被称为元组。
	元组看起来犹如列表，但是使用圆括号而不是方括号来标识。元组的访问跟列表相同。
	dimensions=(200,50,30,100) 定义元组
	dimensions[0]=100	错误操作，元组的元素是无法改变的
	dimensions=(300,200) 重新定义了元组，之前的元组变量就被覆盖了，不存在了。

9	检查列表中是否包含特定的值
	names=['jack','rose','tom']
	'rose' in names --------> 关键词in,返回true代表在列表中，false代表不在列表中
	‘rose' not in names -----> 关键词not in 返回true代表不在列表中，false代表在列表中


10	if-elif-else(可使用多个elif，省略else)语句
	if age < 4:
		print age
	elif age < 18:
		print age
	else:
		print age

11	字典(列表相当于c语言中的数组，而字典就相当于c语言中的结构一样)
	字典可存储的信息量几乎不受限制，可以有：存储字典的列表，存储列表的字典，存储字典的字典
	在 Python 中,字典 是一系列键 — 值对 。每个键 都与一个值相关联,你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上,可将任何 Python 对象用作字典中的值。
	字典以花括号标识，键与其对应的值之间使用冒号(:)分割，每一对键值对之间使用逗号(，)间隔
	alien_0={'color':'green','points':5}
	print alien_0['color'] -----> green 访问方法
	alien_0['x_position']=0 --------> 在字典中增加了一对键值对'x_position':0
	del alien_0['color'] ----------> 删除字典中的'color'键值对
	for x,y in alien_0.items():
		print x,y -----------------> 遍历字典中的键值对，每次将一对键值对存入x,y中，x为键，y为值
	for x in alien_0.items():
		print x -------------------> 遍历字典中的键值对，将每一对键值对存入x中，x为一个键值对元组
	for x in alien_0.keys():
		print x -------------------> 遍历字典中的所有键，不关心其对应的值
	for x in sorted(alien_0.keys()):
		print x -------------------> 按顺序遍历字典中所有的键
	for x in alien_0.values():
		print x -------------------> 遍历字典中所有的值，不关心其对应的键
	set(alien_0.values()) ---------> 剔除掉values列表中重复的值

12	raw_input()函数 (python3使用input函数)
	函数raw_input()让程序暂停运行，等待用户输入一些文本，获取用户输入后，将其存储在一个变量中，方便使用。
	message=raw_input("please input something:")
	print message

13	使用列表副本
	print_models(models) ----------> 会修改models列表变量本身
	print_models(models[:]) -------> 不会修改models列表变量本身，models[:]是创建了一个models的副本

14	传递任意数量的实参
	def make_pizza(*toppings):
		print toppings
	make_pizza('pepperoni') -------------------------------------> 传递1个实参也行
	make_pizza('mushrooms','green peppers','extra cheese') ------> 传递3个实参也行
	python会将接收到的实参都封装到topping元组中去

	def build_profile(first,last,**user_info):
		#函数code
	build_profile('albert','einstein',location='princeton',field='physics')
	python会创建一个名为user——info的空字典，并将收到的所有名称——值对都封装到这个字典中去

15	导入函数
	直接import javenlib，在后面使用函数的时候就需要使用句点表示法，如javenlib.image_rotate()
	使用from javenlib import image_rotate 或者from javenlib import * 就不需要句点表示法，直接使用 image_rotate()

16	类（python2.7中类定义需要传入object参数，即class Dog(object)）
	class Dog():
		""" 一次模拟小狗的简单尝试 """
		def __init__(self, name, age):
			""" 初始化属性 name 和 age"""
			self.name = name
			self.age = age
		def sit(self):
			""" 模拟小狗被命令时蹲下 """
			print(self.name.title() + " is now sitting.")
		def roll_over(self):
			""" 模拟小狗被命令时打滚 """
			print(self.name.title() + " rolled over!")

	class BigDog(Dog): ---------->子类BigDog继承父类Dog(super调用父类，self调用自己)

17	文件读取操作
	with open('pi_digits.txt') as file_object: 	#使用with就可以省略close()
		contents = file_object.read()
		print(contents.rstrip())

	关键字 with 在不再需要访问文件后将其关闭。在这个程序中,注意到我们调用了 open() ,但没有调用 close() ;你也可以调用 open() 和 close() 来打开和关闭文件,但这样做时,如果程序存在 bug ,导致 close() 语句未执行,文件将不会关闭。这看似微不足道,但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调	用 close() ,你会发现需要使用文件时它已关闭 (无法访问),这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机,但通过使用前面所示的结构,可让 Python 去确定:你只管打开文件,并在需要时使用它, Python 自会在合适的时候自动将其关闭。

	with open(filename) as file_object:
		lines = file_object.readlines() readlines() 从文件中读取每一行,并将其存储在一个列表中;接下来,该列表被存储到变量 lines 中;在 with 代码块外,我们依然可以使用这个变量
	for line in lines:
		print line.rstrip()

	写入文件
	filename = 'programming.txt'
	with open(filename, 'w') as file_object:
		file_object.write("I love programming.")

18	异常，使用try-except代码块,避免程序崩溃影响后面的code的执行
	Python 使用被称为异常 的特殊对象来管理程序执行期间发生的错误。每当发生让 Python 不知所措的错误时,它都会创建一个异常对象。如果你编写了处理该异常的代码,程序将继续运行;如果你未对异常进行处理,程序将停止,并显示一个 traceback ,其中包含有关异常的报告。
	当你认为可能发生了错误时,可编写一个 try-except 代码块来处理可能引发的异常。你让 Python 尝试运行一些代码,并告诉它如果这些代码引发了指定的异常,该怎么办。
	处理 ZeroDivisionError 异常的 try-except 代码块类似于下面这样:
	try:
		print(5/0)
	except ZeroDivisionError: #当python产生ZeroDivisionError异常时执行下面的code
		print("You can't divide by zero!")
	else:
		print(answer) #当try下面的code执行成功就接着执行else下面的code

	所以要想写异常处理的code，编程者必须对python会产生的常见的异常的名称很熟悉，例如常见的找不到文件的异常叫做: FileNotFoundError

	try:
		with open(filename) as f_obj:
			contents = f_obj.read()
	except FileNotFoundError:
		msg = "Sorry, the file " + filename + " does not exist."
		print(msg)

	Python 有一个 pass 语句,可在代码块中使用它来让 Python什么都不要做

19	存储数据结构变量，而不是单纯的文本 (json)
	模块 json 让你能够将简单的 Python 数据结构转储到文件中,并在程序再次运行时加载该文件中的数据。你还可以使用 json 在 Python 程序之间分享数据。更重要的是, JSON 数据格式并非 Python 专用的,这让你能够将以 JSON 格式存储的数据与使用其他编程语言的人分享。这是一种轻便格式,很有用,也易于学习。JSON ( JavaScript Object Notation )格式最初是为 JavaScript 开发的,但随后成了一种常见格式,被包括 Python 在内的众多语言采用。

	使用json.dump(x,file)来存储数据到文件，文件后缀为.json:
	import json
	numbers=[2,3,5,7,11,13]
	filename='numbers.json'
	with open(filename,'w') as f_obj:
		json.dump(numbers,f_obj)

	使用json.load(file)将数据读取到内存中:
	import json
	filename='numbers.json'
	with open(filename) as f_obj:
		numbers=json.load(f_obj)
	print numbers












































































