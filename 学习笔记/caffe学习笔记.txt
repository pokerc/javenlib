1.	caffe网络框架结构描述文件 例如：lenet_train_test.prototxt

2.	caffe网络权重值配置文件 例如：lenet_iter_10000.caffemodel

3.	用于CNN计算的image需要使用caffe.io.load_image来读入，其存储的是float类型的数据。而用于寻找features以及生成descriptors的image需要使用cv2.imread来读入，其存储的是uint8类型的数据

4.	安装opencv with contrib
下载opencv-master 以及 opencv_contrib-master ，解压
之后，按照命令
$ cd <opencv_source_directory>
$ mkdir build
$ cd build
$ cmake.. -DOPENCV_EXTRA_MODULES_PATH=<opencv_contrib>/modules <opencv_source_directory>
$ make -j5
之后在opencv-master/build/lib文件夹下就有cv2.so库文件了，可以不用安装，直接将路径添加给python方法如下：
在.bashrc中加入
export PYTHONPATH=/home/javen/opencv-master/build/lib:$PYTHONPATH

5.安装最终使用的是opencv2，因为opencv3与caffe的protobuf版本存在冲突。在import的时候需要先导入cv2在导入caffe否则会出现报错的情况。同样的情况还有，(osx中)在matplotlib.pyplot之前导入caffe(ubuntu中没有遇到这个问题)。

6.	cv2.imread()读取的图片是width*columns*tunnels
  cv2中的sift和surf得到的keypoints得到的点(x,y)，前面的x代表的是点column的位置,y代表的是width的位置,坐标轴是对应的，要注意区分防止出错。

7.	caffe的model_def参数使用的是lenet.prototxt,该文件中定义的是整个网络结构的每一层的输入输出形式信息。

8.	cv2.imread读入的通道顺序是b,g,r，而caffe.io.load_image读入的是r,g,b

9.	输入cnn之前数据是29*29*3，经过transformer处理，首先将通道移到前面变成3*29*29，然后进行放大即每个像素三个通道的值都乘以255，因为caffe在读取的时候是变为0-1之间的值的，然后在将通道顺序由RGB转为BGR，然后对每一个像素减去同样的固定的BGR均值，之后再输入net中进行处理

10.	



















